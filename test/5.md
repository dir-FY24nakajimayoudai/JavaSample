1. ~~A~~  
    **A** C
    `var`はメンバ変数に使用できない、`final`を付けると初期値が必要なので、合計ー２で３つがコンパイル成功する
2. B,~~E~~
    **A** C
    選択肢C：宣言と代入を`;`で分けた表記なのでOK
    選択肢E：コンストラクタの呼び出しが無いためコンパイルエラーになる
3. ~~E~~,F
    **A** D
    D：メソッドの処理がなくてもコンパイルは通るのでOK
    E：戻り値に`String`を指定しているが、ブロック内で`return`していないのて不適
4. B
5. A,E
6. A
7. ~~A~~
    **A** C
    `this()`を使った記述は、他コンストラクターを呼び出す。呼び出したコンストラクターではメンバ変数への代入が行われてないため、どちらのオブジェクトもメンバ変数の値が初期値のままなのでCが正解。
8. ~~A~~
    **A** B
9. ~~B~~
    **A** E
    デフォルトコンストラクタが生成されるのはクラスは、コンストラクタが定義されていない場合のみ。Sample3に記述されているのは`void`がついているメソッドのみなので、Sample3もデフォルトコンストラクタが生成される
10. B,F,D
    **補足** 別のコンストラクタの呼び出しはコンストラクタ内の先頭に記述する必要がある
11. A,B,~~D~~,E
    **A** C
    D：引数の変数の型宣言に`var`を用いているが、型推論ができないため不適
12. CD
13. E
    **補足** コンストラクター内で別コンストラクターの呼び出しは１回のみ行える
14. ~~F~~
    **A** A
    `bar()`暗黙の型変換やオートボクシングが働く場合、暗黙の型変換の方がオートボクシングよりも優先して行われるため、`t.bar(7)`は`float i = 7`として処理される
15. E
16. ？
    **A** D
    9行目の`Counter.reset()`では、オブジェクト化をせずにインスタンスメンバを呼び出しているのでコンパイルエラーになる
17. ~~E,(D)~~
    **A** C
    `method()`メソッドで`f = null`をしているが、スコープ的に配列の要素自体がnullになったわけではない。
18. C
19. 